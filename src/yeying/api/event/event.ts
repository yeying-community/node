// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: yeying/api/event/event.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { MessageHeader, ResponseStatus } from "../common/message";

export const protobufPackage = "yeying.api.event";

export enum EventTypeEnum {
  /** EVENT_TYPE_UNKNOWN - 未知事件类型，是一种占位符 */
  EVENT_TYPE_UNKNOWN = 0,
  /** EVENT_TYPE_REMIND - 提醒事件，需要被通知方查看事件，比如生日提醒、会议提醒等 */
  EVENT_TYPE_REMIND = 1,
  /** EVENT_TYPE_NOTIFY - 通知事件，需要被通知方获取内容，通常是信息比较大，并发生了更新，需要用户按需获取 */
  EVENT_TYPE_NOTIFY = 2,
  /** EVENT_TYPE_APPLY - 申请事件，需要被通知方做出通过或者拒绝，比如审核账户、网络准入等 */
  EVENT_TYPE_APPLY = 3,
  /** EVENT_TYPE_CUSTOM - 自定义事件，需要被通知方基于事件内容做出响应行动 */
  EVENT_TYPE_CUSTOM = 4,
  UNRECOGNIZED = -1,
}

export function eventTypeEnumFromJSON(object: any): EventTypeEnum {
  switch (object) {
    case 0:
    case "EVENT_TYPE_UNKNOWN":
      return EventTypeEnum.EVENT_TYPE_UNKNOWN;
    case 1:
    case "EVENT_TYPE_REMIND":
      return EventTypeEnum.EVENT_TYPE_REMIND;
    case 2:
    case "EVENT_TYPE_NOTIFY":
      return EventTypeEnum.EVENT_TYPE_NOTIFY;
    case 3:
    case "EVENT_TYPE_APPLY":
      return EventTypeEnum.EVENT_TYPE_APPLY;
    case 4:
    case "EVENT_TYPE_CUSTOM":
      return EventTypeEnum.EVENT_TYPE_CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventTypeEnum.UNRECOGNIZED;
  }
}

export function eventTypeEnumToJSON(object: EventTypeEnum): string {
  switch (object) {
    case EventTypeEnum.EVENT_TYPE_UNKNOWN:
      return "EVENT_TYPE_UNKNOWN";
    case EventTypeEnum.EVENT_TYPE_REMIND:
      return "EVENT_TYPE_REMIND";
    case EventTypeEnum.EVENT_TYPE_NOTIFY:
      return "EVENT_TYPE_NOTIFY";
    case EventTypeEnum.EVENT_TYPE_APPLY:
      return "EVENT_TYPE_APPLY";
    case EventTypeEnum.EVENT_TYPE_CUSTOM:
      return "EVENT_TYPE_CUSTOM";
    case EventTypeEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ApplyActionEnum {
  /** APPLY_ACTION_UNKNOWN - 未知申请事件的行为类型，是一种占位符 */
  APPLY_ACTION_UNKNOWN = 0,
  /** APPLY_ACTION_PASSED - 申请通过 */
  APPLY_ACTION_PASSED = 1,
  /** APPLY_ACTION_REFUSED - 申请拒绝 */
  APPLY_ACTION_REFUSED = 2,
  UNRECOGNIZED = -1,
}

export function applyActionEnumFromJSON(object: any): ApplyActionEnum {
  switch (object) {
    case 0:
    case "APPLY_ACTION_UNKNOWN":
      return ApplyActionEnum.APPLY_ACTION_UNKNOWN;
    case 1:
    case "APPLY_ACTION_PASSED":
      return ApplyActionEnum.APPLY_ACTION_PASSED;
    case 2:
    case "APPLY_ACTION_REFUSED":
      return ApplyActionEnum.APPLY_ACTION_REFUSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ApplyActionEnum.UNRECOGNIZED;
  }
}

export function applyActionEnumToJSON(object: ApplyActionEnum): string {
  switch (object) {
    case ApplyActionEnum.APPLY_ACTION_UNKNOWN:
      return "APPLY_ACTION_UNKNOWN";
    case ApplyActionEnum.APPLY_ACTION_PASSED:
      return "APPLY_ACTION_PASSED";
    case ApplyActionEnum.APPLY_ACTION_REFUSED:
      return "APPLY_ACTION_REFUSED";
    case ApplyActionEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NotifyActionEnum {
  /** NOTIFY_ACTION_UNKNOWN - 未知通知事件的行为类型，是一种占位符 */
  NOTIFY_ACTION_UNKNOWN = 0,
  /** NOTIFY_ACTION_ADD - 增加 */
  NOTIFY_ACTION_ADD = 1,
  /** NOTIFY_ACTION_DEL - 删除 */
  NOTIFY_ACTION_DEL = 2,
  /** NOTIFY_ACTION_MOD - 修改 */
  NOTIFY_ACTION_MOD = 3,
  UNRECOGNIZED = -1,
}

export function notifyActionEnumFromJSON(object: any): NotifyActionEnum {
  switch (object) {
    case 0:
    case "NOTIFY_ACTION_UNKNOWN":
      return NotifyActionEnum.NOTIFY_ACTION_UNKNOWN;
    case 1:
    case "NOTIFY_ACTION_ADD":
      return NotifyActionEnum.NOTIFY_ACTION_ADD;
    case 2:
    case "NOTIFY_ACTION_DEL":
      return NotifyActionEnum.NOTIFY_ACTION_DEL;
    case 3:
    case "NOTIFY_ACTION_MOD":
      return NotifyActionEnum.NOTIFY_ACTION_MOD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotifyActionEnum.UNRECOGNIZED;
  }
}

export function notifyActionEnumToJSON(object: NotifyActionEnum): string {
  switch (object) {
    case NotifyActionEnum.NOTIFY_ACTION_UNKNOWN:
      return "NOTIFY_ACTION_UNKNOWN";
    case NotifyActionEnum.NOTIFY_ACTION_ADD:
      return "NOTIFY_ACTION_ADD";
    case NotifyActionEnum.NOTIFY_ACTION_DEL:
      return "NOTIFY_ACTION_DEL";
    case NotifyActionEnum.NOTIFY_ACTION_MOD:
      return "NOTIFY_ACTION_MOD";
    case NotifyActionEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EventMetadata {
  uid: string;
  type: EventTypeEnum;
  producers: string[];
  consumers: string[];
  signature: EventSignature | undefined;
  extend: string;
  createdAt: string;
  processedAt: string;
  content?:
    | { $case: "notifyContent"; notifyContent: NotifyContent }
    | { $case: "applyContent"; applyContent: ApplyContent }
    | { $case: "customContent"; customContent: CustomContent }
    | undefined;
  opinion?:
    | { $case: "notifyOpinion"; notifyOpinion: NotifyOpinion }
    | { $case: "applyOpinion"; applyOpinion: ApplyOpinion }
    | { $case: "customOpinion"; customOpinion: CustomOpinion }
    | undefined;
}

export interface SignatureObject {
  uid: string;
  type: EventTypeEnum;
  producers: string[];
  consumers: string[];
  signature: Uint8Array;
  extend: string;
  createdAt: string;
  processedAt: string;
  opinion: Uint8Array;
  content: Uint8Array;
}

export interface EventSignature {
  producers: string[];
  consumers: string[];
}

export interface CustomContent {
  name: string;
  object: string;
}

export interface ApplyContent {
  applier: string;
}

export interface NotifyContent {
  name: string;
  items: NotifyItem[];
}

export interface NotifyItem {
  uid: string;
  action: NotifyActionEnum;
}

export interface ProduceRequest {
  header: MessageHeader | undefined;
  body: ProduceRequestBody | undefined;
}

export interface ProduceRequestBody {
  event: EventMetadata | undefined;
}

export interface ProduceResponse {
  header: MessageHeader | undefined;
  body: ProduceResponseBody | undefined;
}

export interface ProduceResponseBody {
  status: ResponseStatus | undefined;
}

export interface ConsumeRequest {
  header: MessageHeader | undefined;
  body: ConsumeRequestBody | undefined;
}

export interface ConsumeRequestBody {
  metadata: EventMetadata | undefined;
}

export interface NotifyOpinion {
  processed: string;
}

export interface ApplyOpinion {
  action: ApplyActionEnum;
  cause: string;
  processed: string;
}

export interface CustomOpinion {
  name: string;
  object: string;
}

export interface ConsumeResponse {
  header: MessageHeader | undefined;
  body: ConsumeResponseBody | undefined;
}

export interface ConsumeResponseBody {
  status: ResponseStatus | undefined;
}

function createBaseEventMetadata(): EventMetadata {
  return {
    uid: "",
    type: 0,
    producers: [],
    consumers: [],
    signature: undefined,
    extend: "",
    createdAt: "",
    processedAt: "",
    content: undefined,
    opinion: undefined,
  };
}

export const EventMetadata: MessageFns<EventMetadata> = {
  encode(message: EventMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    for (const v of message.producers) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.consumers) {
      writer.uint32(34).string(v!);
    }
    if (message.signature !== undefined) {
      EventSignature.encode(message.signature, writer.uint32(42).fork()).join();
    }
    if (message.extend !== "") {
      writer.uint32(50).string(message.extend);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.processedAt !== "") {
      writer.uint32(66).string(message.processedAt);
    }
    switch (message.content?.$case) {
      case "notifyContent":
        NotifyContent.encode(message.content.notifyContent, writer.uint32(74).fork()).join();
        break;
      case "applyContent":
        ApplyContent.encode(message.content.applyContent, writer.uint32(82).fork()).join();
        break;
      case "customContent":
        CustomContent.encode(message.content.customContent, writer.uint32(90).fork()).join();
        break;
    }
    switch (message.opinion?.$case) {
      case "notifyOpinion":
        NotifyOpinion.encode(message.opinion.notifyOpinion, writer.uint32(98).fork()).join();
        break;
      case "applyOpinion":
        ApplyOpinion.encode(message.opinion.applyOpinion, writer.uint32(106).fork()).join();
        break;
      case "customOpinion":
        CustomOpinion.encode(message.opinion.customOpinion, writer.uint32(114).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.producers.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.consumers.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = EventSignature.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.extend = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.processedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.content = { $case: "notifyContent", notifyContent: NotifyContent.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.content = { $case: "applyContent", applyContent: ApplyContent.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.content = { $case: "customContent", customContent: CustomContent.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.opinion = { $case: "notifyOpinion", notifyOpinion: NotifyOpinion.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.opinion = { $case: "applyOpinion", applyOpinion: ApplyOpinion.decode(reader, reader.uint32()) };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.opinion = { $case: "customOpinion", customOpinion: CustomOpinion.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMetadata {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      type: isSet(object.type) ? eventTypeEnumFromJSON(object.type) : 0,
      producers: globalThis.Array.isArray(object?.producers)
        ? object.producers.map((e: any) => globalThis.String(e))
        : [],
      consumers: globalThis.Array.isArray(object?.consumers)
        ? object.consumers.map((e: any) => globalThis.String(e))
        : [],
      signature: isSet(object.signature) ? EventSignature.fromJSON(object.signature) : undefined,
      extend: isSet(object.extend) ? globalThis.String(object.extend) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      processedAt: isSet(object.processedAt) ? globalThis.String(object.processedAt) : "",
      content: isSet(object.notifyContent)
        ? { $case: "notifyContent", notifyContent: NotifyContent.fromJSON(object.notifyContent) }
        : isSet(object.applyContent)
        ? { $case: "applyContent", applyContent: ApplyContent.fromJSON(object.applyContent) }
        : isSet(object.customContent)
        ? { $case: "customContent", customContent: CustomContent.fromJSON(object.customContent) }
        : undefined,
      opinion: isSet(object.notifyOpinion)
        ? { $case: "notifyOpinion", notifyOpinion: NotifyOpinion.fromJSON(object.notifyOpinion) }
        : isSet(object.applyOpinion)
        ? { $case: "applyOpinion", applyOpinion: ApplyOpinion.fromJSON(object.applyOpinion) }
        : isSet(object.customOpinion)
        ? { $case: "customOpinion", customOpinion: CustomOpinion.fromJSON(object.customOpinion) }
        : undefined,
    };
  },

  toJSON(message: EventMetadata): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.type !== 0) {
      obj.type = eventTypeEnumToJSON(message.type);
    }
    if (message.producers?.length) {
      obj.producers = message.producers;
    }
    if (message.consumers?.length) {
      obj.consumers = message.consumers;
    }
    if (message.signature !== undefined) {
      obj.signature = EventSignature.toJSON(message.signature);
    }
    if (message.extend !== "") {
      obj.extend = message.extend;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.processedAt !== "") {
      obj.processedAt = message.processedAt;
    }
    if (message.content?.$case === "notifyContent") {
      obj.notifyContent = NotifyContent.toJSON(message.content.notifyContent);
    } else if (message.content?.$case === "applyContent") {
      obj.applyContent = ApplyContent.toJSON(message.content.applyContent);
    } else if (message.content?.$case === "customContent") {
      obj.customContent = CustomContent.toJSON(message.content.customContent);
    }
    if (message.opinion?.$case === "notifyOpinion") {
      obj.notifyOpinion = NotifyOpinion.toJSON(message.opinion.notifyOpinion);
    } else if (message.opinion?.$case === "applyOpinion") {
      obj.applyOpinion = ApplyOpinion.toJSON(message.opinion.applyOpinion);
    } else if (message.opinion?.$case === "customOpinion") {
      obj.customOpinion = CustomOpinion.toJSON(message.opinion.customOpinion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMetadata>, I>>(base?: I): EventMetadata {
    return EventMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMetadata>, I>>(object: I): EventMetadata {
    const message = createBaseEventMetadata();
    message.uid = object.uid ?? "";
    message.type = object.type ?? 0;
    message.producers = object.producers?.map((e) => e) || [];
    message.consumers = object.consumers?.map((e) => e) || [];
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? EventSignature.fromPartial(object.signature)
      : undefined;
    message.extend = object.extend ?? "";
    message.createdAt = object.createdAt ?? "";
    message.processedAt = object.processedAt ?? "";
    switch (object.content?.$case) {
      case "notifyContent": {
        if (object.content?.notifyContent !== undefined && object.content?.notifyContent !== null) {
          message.content = {
            $case: "notifyContent",
            notifyContent: NotifyContent.fromPartial(object.content.notifyContent),
          };
        }
        break;
      }
      case "applyContent": {
        if (object.content?.applyContent !== undefined && object.content?.applyContent !== null) {
          message.content = {
            $case: "applyContent",
            applyContent: ApplyContent.fromPartial(object.content.applyContent),
          };
        }
        break;
      }
      case "customContent": {
        if (object.content?.customContent !== undefined && object.content?.customContent !== null) {
          message.content = {
            $case: "customContent",
            customContent: CustomContent.fromPartial(object.content.customContent),
          };
        }
        break;
      }
    }
    switch (object.opinion?.$case) {
      case "notifyOpinion": {
        if (object.opinion?.notifyOpinion !== undefined && object.opinion?.notifyOpinion !== null) {
          message.opinion = {
            $case: "notifyOpinion",
            notifyOpinion: NotifyOpinion.fromPartial(object.opinion.notifyOpinion),
          };
        }
        break;
      }
      case "applyOpinion": {
        if (object.opinion?.applyOpinion !== undefined && object.opinion?.applyOpinion !== null) {
          message.opinion = {
            $case: "applyOpinion",
            applyOpinion: ApplyOpinion.fromPartial(object.opinion.applyOpinion),
          };
        }
        break;
      }
      case "customOpinion": {
        if (object.opinion?.customOpinion !== undefined && object.opinion?.customOpinion !== null) {
          message.opinion = {
            $case: "customOpinion",
            customOpinion: CustomOpinion.fromPartial(object.opinion.customOpinion),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSignatureObject(): SignatureObject {
  return {
    uid: "",
    type: 0,
    producers: [],
    consumers: [],
    signature: new Uint8Array(0),
    extend: "",
    createdAt: "",
    processedAt: "",
    opinion: new Uint8Array(0),
    content: new Uint8Array(0),
  };
}

export const SignatureObject: MessageFns<SignatureObject> = {
  encode(message: SignatureObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    for (const v of message.producers) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.consumers) {
      writer.uint32(34).string(v!);
    }
    if (message.signature.length !== 0) {
      writer.uint32(42).bytes(message.signature);
    }
    if (message.extend !== "") {
      writer.uint32(50).string(message.extend);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.processedAt !== "") {
      writer.uint32(66).string(message.processedAt);
    }
    if (message.opinion.length !== 0) {
      writer.uint32(74).bytes(message.opinion);
    }
    if (message.content.length !== 0) {
      writer.uint32(82).bytes(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.producers.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.consumers.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.extend = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.processedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.opinion = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.content = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureObject {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      type: isSet(object.type) ? eventTypeEnumFromJSON(object.type) : 0,
      producers: globalThis.Array.isArray(object?.producers)
        ? object.producers.map((e: any) => globalThis.String(e))
        : [],
      consumers: globalThis.Array.isArray(object?.consumers)
        ? object.consumers.map((e: any) => globalThis.String(e))
        : [],
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      extend: isSet(object.extend) ? globalThis.String(object.extend) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      processedAt: isSet(object.processedAt) ? globalThis.String(object.processedAt) : "",
      opinion: isSet(object.opinion) ? bytesFromBase64(object.opinion) : new Uint8Array(0),
      content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(0),
    };
  },

  toJSON(message: SignatureObject): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.type !== 0) {
      obj.type = eventTypeEnumToJSON(message.type);
    }
    if (message.producers?.length) {
      obj.producers = message.producers;
    }
    if (message.consumers?.length) {
      obj.consumers = message.consumers;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.extend !== "") {
      obj.extend = message.extend;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.processedAt !== "") {
      obj.processedAt = message.processedAt;
    }
    if (message.opinion.length !== 0) {
      obj.opinion = base64FromBytes(message.opinion);
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignatureObject>, I>>(base?: I): SignatureObject {
    return SignatureObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignatureObject>, I>>(object: I): SignatureObject {
    const message = createBaseSignatureObject();
    message.uid = object.uid ?? "";
    message.type = object.type ?? 0;
    message.producers = object.producers?.map((e) => e) || [];
    message.consumers = object.consumers?.map((e) => e) || [];
    message.signature = object.signature ?? new Uint8Array(0);
    message.extend = object.extend ?? "";
    message.createdAt = object.createdAt ?? "";
    message.processedAt = object.processedAt ?? "";
    message.opinion = object.opinion ?? new Uint8Array(0);
    message.content = object.content ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEventSignature(): EventSignature {
  return { producers: [], consumers: [] };
}

export const EventSignature: MessageFns<EventSignature> = {
  encode(message: EventSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.producers) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.consumers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.producers.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSignature {
    return {
      producers: globalThis.Array.isArray(object?.producers)
        ? object.producers.map((e: any) => globalThis.String(e))
        : [],
      consumers: globalThis.Array.isArray(object?.consumers)
        ? object.consumers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EventSignature): unknown {
    const obj: any = {};
    if (message.producers?.length) {
      obj.producers = message.producers;
    }
    if (message.consumers?.length) {
      obj.consumers = message.consumers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventSignature>, I>>(base?: I): EventSignature {
    return EventSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventSignature>, I>>(object: I): EventSignature {
    const message = createBaseEventSignature();
    message.producers = object.producers?.map((e) => e) || [];
    message.consumers = object.consumers?.map((e) => e) || [];
    return message;
  },
};

function createBaseCustomContent(): CustomContent {
  return { name: "", object: "" };
}

export const CustomContent: MessageFns<CustomContent> = {
  encode(message: CustomContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.object !== "") {
      writer.uint32(18).string(message.object);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.object = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomContent {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
    };
  },

  toJSON(message: CustomContent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomContent>, I>>(base?: I): CustomContent {
    return CustomContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomContent>, I>>(object: I): CustomContent {
    const message = createBaseCustomContent();
    message.name = object.name ?? "";
    message.object = object.object ?? "";
    return message;
  },
};

function createBaseApplyContent(): ApplyContent {
  return { applier: "" };
}

export const ApplyContent: MessageFns<ApplyContent> = {
  encode(message: ApplyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applier !== "") {
      writer.uint32(10).string(message.applier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyContent {
    return { applier: isSet(object.applier) ? globalThis.String(object.applier) : "" };
  },

  toJSON(message: ApplyContent): unknown {
    const obj: any = {};
    if (message.applier !== "") {
      obj.applier = message.applier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyContent>, I>>(base?: I): ApplyContent {
    return ApplyContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyContent>, I>>(object: I): ApplyContent {
    const message = createBaseApplyContent();
    message.applier = object.applier ?? "";
    return message;
  },
};

function createBaseNotifyContent(): NotifyContent {
  return { name: "", items: [] };
}

export const NotifyContent: MessageFns<NotifyContent> = {
  encode(message: NotifyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.items) {
      NotifyItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(NotifyItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotifyContent {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => NotifyItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: NotifyContent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => NotifyItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotifyContent>, I>>(base?: I): NotifyContent {
    return NotifyContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotifyContent>, I>>(object: I): NotifyContent {
    const message = createBaseNotifyContent();
    message.name = object.name ?? "";
    message.items = object.items?.map((e) => NotifyItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNotifyItem(): NotifyItem {
  return { uid: "", action: 0 };
}

export const NotifyItem: MessageFns<NotifyItem> = {
  encode(message: NotifyItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotifyItem {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      action: isSet(object.action) ? notifyActionEnumFromJSON(object.action) : 0,
    };
  },

  toJSON(message: NotifyItem): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.action !== 0) {
      obj.action = notifyActionEnumToJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotifyItem>, I>>(base?: I): NotifyItem {
    return NotifyItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotifyItem>, I>>(object: I): NotifyItem {
    const message = createBaseNotifyItem();
    message.uid = object.uid ?? "";
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseProduceRequest(): ProduceRequest {
  return { header: undefined, body: undefined };
}

export const ProduceRequest: MessageFns<ProduceRequest> = {
  encode(message: ProduceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      ProduceRequestBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProduceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = ProduceRequestBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProduceRequest {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? ProduceRequestBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: ProduceRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = ProduceRequestBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProduceRequest>, I>>(base?: I): ProduceRequest {
    return ProduceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProduceRequest>, I>>(object: I): ProduceRequest {
    const message = createBaseProduceRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? ProduceRequestBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseProduceRequestBody(): ProduceRequestBody {
  return { event: undefined };
}

export const ProduceRequestBody: MessageFns<ProduceRequestBody> = {
  encode(message: ProduceRequestBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      EventMetadata.encode(message.event, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProduceRequestBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduceRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = EventMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProduceRequestBody {
    return { event: isSet(object.event) ? EventMetadata.fromJSON(object.event) : undefined };
  },

  toJSON(message: ProduceRequestBody): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = EventMetadata.toJSON(message.event);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProduceRequestBody>, I>>(base?: I): ProduceRequestBody {
    return ProduceRequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProduceRequestBody>, I>>(object: I): ProduceRequestBody {
    const message = createBaseProduceRequestBody();
    message.event = (object.event !== undefined && object.event !== null)
      ? EventMetadata.fromPartial(object.event)
      : undefined;
    return message;
  },
};

function createBaseProduceResponse(): ProduceResponse {
  return { header: undefined, body: undefined };
}

export const ProduceResponse: MessageFns<ProduceResponse> = {
  encode(message: ProduceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      ProduceResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProduceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = ProduceResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProduceResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? ProduceResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: ProduceResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = ProduceResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProduceResponse>, I>>(base?: I): ProduceResponse {
    return ProduceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProduceResponse>, I>>(object: I): ProduceResponse {
    const message = createBaseProduceResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? ProduceResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseProduceResponseBody(): ProduceResponseBody {
  return { status: undefined };
}

export const ProduceResponseBody: MessageFns<ProduceResponseBody> = {
  encode(message: ProduceResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProduceResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduceResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProduceResponseBody {
    return { status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined };
  },

  toJSON(message: ProduceResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProduceResponseBody>, I>>(base?: I): ProduceResponseBody {
    return ProduceResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProduceResponseBody>, I>>(object: I): ProduceResponseBody {
    const message = createBaseProduceResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseConsumeRequest(): ConsumeRequest {
  return { header: undefined, body: undefined };
}

export const ConsumeRequest: MessageFns<ConsumeRequest> = {
  encode(message: ConsumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      ConsumeRequestBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = ConsumeRequestBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumeRequest {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? ConsumeRequestBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: ConsumeRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = ConsumeRequestBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumeRequest>, I>>(base?: I): ConsumeRequest {
    return ConsumeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumeRequest>, I>>(object: I): ConsumeRequest {
    const message = createBaseConsumeRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? ConsumeRequestBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseConsumeRequestBody(): ConsumeRequestBody {
  return { metadata: undefined };
}

export const ConsumeRequestBody: MessageFns<ConsumeRequestBody> = {
  encode(message: ConsumeRequestBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      EventMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumeRequestBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumeRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = EventMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumeRequestBody {
    return { metadata: isSet(object.metadata) ? EventMetadata.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: ConsumeRequestBody): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = EventMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumeRequestBody>, I>>(base?: I): ConsumeRequestBody {
    return ConsumeRequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumeRequestBody>, I>>(object: I): ConsumeRequestBody {
    const message = createBaseConsumeRequestBody();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? EventMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseNotifyOpinion(): NotifyOpinion {
  return { processed: "" };
}

export const NotifyOpinion: MessageFns<NotifyOpinion> = {
  encode(message: NotifyOpinion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processed !== "") {
      writer.uint32(10).string(message.processed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyOpinion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyOpinion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processed = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotifyOpinion {
    return { processed: isSet(object.processed) ? globalThis.String(object.processed) : "" };
  },

  toJSON(message: NotifyOpinion): unknown {
    const obj: any = {};
    if (message.processed !== "") {
      obj.processed = message.processed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotifyOpinion>, I>>(base?: I): NotifyOpinion {
    return NotifyOpinion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotifyOpinion>, I>>(object: I): NotifyOpinion {
    const message = createBaseNotifyOpinion();
    message.processed = object.processed ?? "";
    return message;
  },
};

function createBaseApplyOpinion(): ApplyOpinion {
  return { action: 0, cause: "", processed: "" };
}

export const ApplyOpinion: MessageFns<ApplyOpinion> = {
  encode(message: ApplyOpinion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.cause !== "") {
      writer.uint32(18).string(message.cause);
    }
    if (message.processed !== "") {
      writer.uint32(26).string(message.processed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyOpinion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyOpinion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cause = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processed = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyOpinion {
    return {
      action: isSet(object.action) ? applyActionEnumFromJSON(object.action) : 0,
      cause: isSet(object.cause) ? globalThis.String(object.cause) : "",
      processed: isSet(object.processed) ? globalThis.String(object.processed) : "",
    };
  },

  toJSON(message: ApplyOpinion): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = applyActionEnumToJSON(message.action);
    }
    if (message.cause !== "") {
      obj.cause = message.cause;
    }
    if (message.processed !== "") {
      obj.processed = message.processed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyOpinion>, I>>(base?: I): ApplyOpinion {
    return ApplyOpinion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyOpinion>, I>>(object: I): ApplyOpinion {
    const message = createBaseApplyOpinion();
    message.action = object.action ?? 0;
    message.cause = object.cause ?? "";
    message.processed = object.processed ?? "";
    return message;
  },
};

function createBaseCustomOpinion(): CustomOpinion {
  return { name: "", object: "" };
}

export const CustomOpinion: MessageFns<CustomOpinion> = {
  encode(message: CustomOpinion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.object !== "") {
      writer.uint32(18).string(message.object);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomOpinion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomOpinion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.object = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomOpinion {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
    };
  },

  toJSON(message: CustomOpinion): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomOpinion>, I>>(base?: I): CustomOpinion {
    return CustomOpinion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomOpinion>, I>>(object: I): CustomOpinion {
    const message = createBaseCustomOpinion();
    message.name = object.name ?? "";
    message.object = object.object ?? "";
    return message;
  },
};

function createBaseConsumeResponse(): ConsumeResponse {
  return { header: undefined, body: undefined };
}

export const ConsumeResponse: MessageFns<ConsumeResponse> = {
  encode(message: ConsumeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      ConsumeResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = ConsumeResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumeResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? ConsumeResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: ConsumeResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = ConsumeResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumeResponse>, I>>(base?: I): ConsumeResponse {
    return ConsumeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumeResponse>, I>>(object: I): ConsumeResponse {
    const message = createBaseConsumeResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? ConsumeResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseConsumeResponseBody(): ConsumeResponseBody {
  return { status: undefined };
}

export const ConsumeResponseBody: MessageFns<ConsumeResponseBody> = {
  encode(message: ConsumeResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumeResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumeResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumeResponseBody {
    return { status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined };
  },

  toJSON(message: ConsumeResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumeResponseBody>, I>>(base?: I): ConsumeResponseBody {
    return ConsumeResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumeResponseBody>, I>>(object: I): ConsumeResponseBody {
    const message = createBaseConsumeResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

export type EventService = typeof EventService;
export const EventService = {
  /** 某个服务作为客户端生成了事件，通常node会实现服务端，然后同步给用户 */
  produce: {
    path: "/yeying.api.event.Event/Produce",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProduceRequest) => Buffer.from(ProduceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProduceRequest.decode(value),
    responseSerialize: (value: ProduceResponse) => Buffer.from(ProduceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProduceResponse.decode(value),
  },
  /** 用户直接向生成事件的服务消费并给出处理意见 */
  consume: {
    path: "/yeying.api.event.Event/Consume",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ConsumeRequest) => Buffer.from(ConsumeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ConsumeRequest.decode(value),
    responseSerialize: (value: ConsumeResponse) => Buffer.from(ConsumeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ConsumeResponse.decode(value),
  },
} as const;

export interface EventServer extends UntypedServiceImplementation {
  /** 某个服务作为客户端生成了事件，通常node会实现服务端，然后同步给用户 */
  produce: handleUnaryCall<ProduceRequest, ProduceResponse>;
  /** 用户直接向生成事件的服务消费并给出处理意见 */
  consume: handleUnaryCall<ConsumeRequest, ConsumeResponse>;
}

export interface EventClient extends Client {
  /** 某个服务作为客户端生成了事件，通常node会实现服务端，然后同步给用户 */
  produce(
    request: ProduceRequest,
    callback: (error: ServiceError | null, response: ProduceResponse) => void,
  ): ClientUnaryCall;
  produce(
    request: ProduceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ProduceResponse) => void,
  ): ClientUnaryCall;
  produce(
    request: ProduceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ProduceResponse) => void,
  ): ClientUnaryCall;
  /** 用户直接向生成事件的服务消费并给出处理意见 */
  consume(
    request: ConsumeRequest,
    callback: (error: ServiceError | null, response: ConsumeResponse) => void,
  ): ClientUnaryCall;
  consume(
    request: ConsumeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ConsumeResponse) => void,
  ): ClientUnaryCall;
  consume(
    request: ConsumeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ConsumeResponse) => void,
  ): ClientUnaryCall;
}

export const EventClient = makeGenericClientConstructor(EventService, "yeying.api.event.Event") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): EventClient;
  service: typeof EventService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
