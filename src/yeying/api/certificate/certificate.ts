// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: yeying/api/certificate/certificate.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { MessageHeader, ResponseStatus } from "../common/message";

export const protobufPackage = "yeying.api.certificate";

export interface SignRequest {
  header: MessageHeader | undefined;
  body: SignRequestBody | undefined;
}

export interface SignRequestBody {
  domain: string;
  csr: string;
}

export interface SignResponse {
  header: MessageHeader | undefined;
  body: SignResponseBody | undefined;
}

export interface CertificateMetadata {
  crt: string;
  ca: string;
}

export interface SignResponseBody {
  status: ResponseStatus | undefined;
  certificate: CertificateMetadata | undefined;
}

export interface GetRequest {
  header: MessageHeader | undefined;
}

export interface GetResponse {
  header: MessageHeader | undefined;
  body: GetResponseBody | undefined;
}

export interface GetResponseBody {
  status: ResponseStatus | undefined;
  certificate: CertificateMetadata | undefined;
}

function createBaseSignRequest(): SignRequest {
  return { header: undefined, body: undefined };
}

export const SignRequest: MessageFns<SignRequest> = {
  encode(message: SignRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      SignRequestBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = SignRequestBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignRequest {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? SignRequestBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: SignRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = SignRequestBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignRequest>, I>>(base?: I): SignRequest {
    return SignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignRequest>, I>>(object: I): SignRequest {
    const message = createBaseSignRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? SignRequestBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseSignRequestBody(): SignRequestBody {
  return { domain: "", csr: "" };
}

export const SignRequestBody: MessageFns<SignRequestBody> = {
  encode(message: SignRequestBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.csr !== "") {
      writer.uint32(18).string(message.csr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignRequestBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.csr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignRequestBody {
    return {
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      csr: isSet(object.csr) ? globalThis.String(object.csr) : "",
    };
  },

  toJSON(message: SignRequestBody): unknown {
    const obj: any = {};
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.csr !== "") {
      obj.csr = message.csr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignRequestBody>, I>>(base?: I): SignRequestBody {
    return SignRequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignRequestBody>, I>>(object: I): SignRequestBody {
    const message = createBaseSignRequestBody();
    message.domain = object.domain ?? "";
    message.csr = object.csr ?? "";
    return message;
  },
};

function createBaseSignResponse(): SignResponse {
  return { header: undefined, body: undefined };
}

export const SignResponse: MessageFns<SignResponse> = {
  encode(message: SignResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      SignResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = SignResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? SignResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: SignResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = SignResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignResponse>, I>>(base?: I): SignResponse {
    return SignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignResponse>, I>>(object: I): SignResponse {
    const message = createBaseSignResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? SignResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseCertificateMetadata(): CertificateMetadata {
  return { crt: "", ca: "" };
}

export const CertificateMetadata: MessageFns<CertificateMetadata> = {
  encode(message: CertificateMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.crt !== "") {
      writer.uint32(10).string(message.crt);
    }
    if (message.ca !== "") {
      writer.uint32(18).string(message.ca);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.crt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ca = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMetadata {
    return {
      crt: isSet(object.crt) ? globalThis.String(object.crt) : "",
      ca: isSet(object.ca) ? globalThis.String(object.ca) : "",
    };
  },

  toJSON(message: CertificateMetadata): unknown {
    const obj: any = {};
    if (message.crt !== "") {
      obj.crt = message.crt;
    }
    if (message.ca !== "") {
      obj.ca = message.ca;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateMetadata>, I>>(base?: I): CertificateMetadata {
    return CertificateMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateMetadata>, I>>(object: I): CertificateMetadata {
    const message = createBaseCertificateMetadata();
    message.crt = object.crt ?? "";
    message.ca = object.ca ?? "";
    return message;
  },
};

function createBaseSignResponseBody(): SignResponseBody {
  return { status: undefined, certificate: undefined };
}

export const SignResponseBody: MessageFns<SignResponseBody> = {
  encode(message: SignResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.certificate !== undefined) {
      CertificateMetadata.encode(message.certificate, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.certificate = CertificateMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignResponseBody {
    return {
      status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined,
      certificate: isSet(object.certificate) ? CertificateMetadata.fromJSON(object.certificate) : undefined,
    };
  },

  toJSON(message: SignResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    if (message.certificate !== undefined) {
      obj.certificate = CertificateMetadata.toJSON(message.certificate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignResponseBody>, I>>(base?: I): SignResponseBody {
    return SignResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignResponseBody>, I>>(object: I): SignResponseBody {
    const message = createBaseSignResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    message.certificate = (object.certificate !== undefined && object.certificate !== null)
      ? CertificateMetadata.fromPartial(object.certificate)
      : undefined;
    return message;
  },
};

function createBaseGetRequest(): GetRequest {
  return { header: undefined };
}

export const GetRequest: MessageFns<GetRequest> = {
  encode(message: GetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequest {
    return { header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined };
  },

  toJSON(message: GetRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRequest>, I>>(base?: I): GetRequest {
    return GetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRequest>, I>>(object: I): GetRequest {
    const message = createBaseGetRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    return message;
  },
};

function createBaseGetResponse(): GetResponse {
  return { header: undefined, body: undefined };
}

export const GetResponse: MessageFns<GetResponse> = {
  encode(message: GetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      GetResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = GetResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? GetResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: GetResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = GetResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResponse>, I>>(base?: I): GetResponse {
    return GetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResponse>, I>>(object: I): GetResponse {
    const message = createBaseGetResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? GetResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseGetResponseBody(): GetResponseBody {
  return { status: undefined, certificate: undefined };
}

export const GetResponseBody: MessageFns<GetResponseBody> = {
  encode(message: GetResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.certificate !== undefined) {
      CertificateMetadata.encode(message.certificate, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.certificate = CertificateMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResponseBody {
    return {
      status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined,
      certificate: isSet(object.certificate) ? CertificateMetadata.fromJSON(object.certificate) : undefined,
    };
  },

  toJSON(message: GetResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    if (message.certificate !== undefined) {
      obj.certificate = CertificateMetadata.toJSON(message.certificate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResponseBody>, I>>(base?: I): GetResponseBody {
    return GetResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResponseBody>, I>>(object: I): GetResponseBody {
    const message = createBaseGetResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    message.certificate = (object.certificate !== undefined && object.certificate !== null)
      ? CertificateMetadata.fromPartial(object.certificate)
      : undefined;
    return message;
  },
};

export type CertificateService = typeof CertificateService;
export const CertificateService = {
  sign: {
    path: "/yeying.api.certificate.Certificate/Sign",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignRequest) => Buffer.from(SignRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SignRequest.decode(value),
    responseSerialize: (value: SignResponse) => Buffer.from(SignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SignResponse.decode(value),
  },
  get: {
    path: "/yeying.api.certificate.Certificate/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRequest) => Buffer.from(GetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetRequest.decode(value),
    responseSerialize: (value: GetResponse) => Buffer.from(GetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetResponse.decode(value),
  },
} as const;

export interface CertificateServer extends UntypedServiceImplementation {
  sign: handleUnaryCall<SignRequest, SignResponse>;
  get: handleUnaryCall<GetRequest, GetResponse>;
}

export interface CertificateClient extends Client {
  sign(request: SignRequest, callback: (error: ServiceError | null, response: SignResponse) => void): ClientUnaryCall;
  sign(
    request: SignRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignResponse) => void,
  ): ClientUnaryCall;
  sign(
    request: SignRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignResponse) => void,
  ): ClientUnaryCall;
  get(request: GetRequest, callback: (error: ServiceError | null, response: GetResponse) => void): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
}

export const CertificateClient = makeGenericClientConstructor(
  CertificateService,
  "yeying.api.certificate.Certificate",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CertificateClient;
  service: typeof CertificateService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
